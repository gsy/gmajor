* vexflow
  - https://github.com/0xfe/vexflow
  - javascript
  - 除了渲染之外，定义了一套 annotation 的编辑语言，相当于一个文本 editor
* 代码阅读
** accidental
   - 升降号
   - 这个符号是添加到 note 上面的
** annotation
   - 文本，应该是注释类的文本
** articulation
   - 加在 note 上面或者下面，表示音量的一个符号
   - 主要是计算 x，y 坐标
** barnote
   - barline
   - 不同类型有不同宽度

** beam
   - 斜率计算：计算第一个 note 和最后一个 note 之间的斜率，note 的坐标是自带的属性
   - beam 是 Element 的一个子类
*** 构建 beam
    - notes: beam 所包含的 notes
    - config
      - groups: notes 的节奏
      - stem direction: 符尾的方向
      - beam_rests:
      - beam_middle_only: true 表示 beam 放到 beat 的中间
      - show_stemlets: true 表示画出 stemlets
      - maintain_stem_directions: true 表示不改变 stem 的方向
    - generate beam
      - 给定一组 notes, 划分到不同的 beam group 中
      - groups 是一个比例，比如 2/8, 遍历所有的 ticks，将 ticks 装到不大于这个比例的 beam group 里面

*** draw
    #+BEGIN_SRC javascript
      draw() {
        this.checkContext();
        this.setRendered();
        if (this.unbeamable) return;

        if (!this.postFormatted) {
          this.postFormat();
        }

        this.drawStems();
        this.applyStyle();
        this.drawBeamLines();
        this.restoreStyle();
      }
    #+END_SRC
    - 画 stem，然后画 beamlines, beamlines 就是一条直线，beamThickness 是直线的宽度
** bend
   - tablature bends
   - 多个符号的连音符
   - 画一条曲线
*** draw 方法
    #+BEGIN_SRC javascript
      const start = this.note.getModifierStartXY(Modifier.Position.RIGHT,
                                                 this.index);
      start.x += 3;
      start.y += 0.5;
      const x_shift = this.x_shift;

      const ctx = this.context;
      const bend_height = this.note.getStave().getYForTopText(this.text_line) + 3;
      const annotation_y = this.note.getStave().getYForTopText(this.text_line) - 1;
      const that = this;

      function renderBend(x, y, width, height) {
        const cp_x = x + width;
        const cp_y = y;

        ctx.save();
        ctx.beginPath();
        ctx.setLineWidth(that.render_options.line_width);
        ctx.setStrokeStyle(that.render_options.line_style);
        ctx.setFillStyle(that.render_options.line_style);
        ctx.moveTo(x, y);
        ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);
        ctx.stroke();
        ctx.restore();
      }

    #+END_SRC
** boudingbox
   - 矩形盒

** canvascontext
   - 宽，高等信息
   - 画图的原语

** clef & clefnote
   - 调性
   - 在一个 stave 中间渲染出来

** crescendo
   - 渐强减弱
   - 画一个半三角形

** curve
   - 贝赛尔曲线
** dot
   - 附点，在 note 旁边画一个实心圆
** element
   - 基类
   - 功能是
     - register
     - get & set attributes
     - get & set context
     - get boudingbox
** formatter
   - layout 计算，先分成最小单元 ticks，ticks 之间有间隔

** fraction
   - 比例
** frethandfinger
   - 指板图？
** glyph
   - 从 font 中根据 code 找到 outline
   - 然后怎么转换成 svg?
*** 例子
    #+BEGIN_SRC javascript
    "v0":{"x_min":0,"x_max":514.5,"ha":525,"o":"m 236 648 b 246 648 238 648 242 648 b 288 646 261 648 283 648 b 472 513 364 634 428 587 b 514 347 502 464 514 413 b 462 163 514 272 499 217 b 257 44 409 83 333 44 b 50 163 181 44 103 83 b 0 347 14 217 0 272 b 40 513 0 413 12 464 b 236 648 87 591 155 638 m 277 614 b 253 616 273 616 261 616 b 242 616 247 616 243 616 b 170 499 193 609 181 589 b 159 348 163 446 159 398 b 166 222 159 308 161 266 b 201 91 174 138 183 106 b 257 76 215 81 235 76 b 311 91 277 76 299 81 b 347 222 330 106 338 138 b 353 348 352 266 353 308 b 344 499 353 398 351 446 b 277 614 333 587 322 606 m 257 -1 l 258 -1 l 255 -1 l 257 -1 m 257 673 l 258 673 l 255 673 l 257 673 "},
    #+END_SRC
    - o 是 outline 的缩写
      - 做了一些转换
      - m: moveTo
      - l: lineTo
      - q: quadraticCurveTo
      - b: bezierCurveTo
    - 所以 glyph 是生画出来的
      - 用的是相对位置，所以问题变成了，font 是怎么来的？怎么转换成符合相对位置画法的数据？
*** 字体是怎么来的？
    - gonville
      - 里面就有 svg 的描述，每个文件是 svg xml
    - 看讨论是 hardcode 的 https://github.com/0xfe/vexflow/issues/181
      - 最终的结论是代码合不进去，整体思路变了




** modifier
   - 修改 note 的类
   - 在 modifiercontext 中使用
** note
   - 属性
     - duration
     - dots
     - noteType
** 基类
   - Element
   - Modifier
   - Glyph
   - Flow
   - Fraction
   - Vex 这个应该是最外层接口

* 问题
  - notehead, clef 这些是怎么画出来的？字体是怎么使用的？
  - 布局看起来是从顶级开始，逐层往下算？
  - 有多少种元素需要画？
  - 跨 bar 的元素是怎么画的？
